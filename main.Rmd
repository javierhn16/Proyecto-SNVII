---
title: "main"
output: html_document
---

# Lectura y librerías
```{r}
pacman::p_load(
  tidyverse,
  lubridate, 
  ggplot2, 
  scales,
  fitdistrplus,
  copula,
  dplyr,
  plotly,
  ChainLadder,
  stats,
  zoo,
  pbapply,
  pracma
)
```

```{r,message=FALSE}
data <- read.csv("data/ausautoBI8999.csv", stringsAsFactors = FALSE) %>%
  arrange(AccMth) %>%
  mutate(
    AccDate = as.Date(AccDate),
    ReportDate = as.Date(ReportDate),
    FinDate = as.Date(FinDate),
    AccMth    = as.yearmon(AccMth, "%Y-%m"),
    ReportMth = as.yearmon(ReportMth, "%Y-%m"),
    FinMth    = as.yearmon(FinMth, "%Y-%m"),
    delay = as.numeric((ReportMth - AccMth)),
    duration = as.numeric(FinMth - AccMth)
  ) %>% 
  filter(AccDate > as.Date("1992-12-31")) %>%
  filter(AccDate < as.Date("1999-1-1")) %>%
  filter(ReportDate < as.Date("1999-1-1")) %>%
  filter(!is.na(delay), !is.na(duration), delay >= 0, duration >= 0) %>%
  dplyr::select(-c(4:6,8:14))
```

# AED
```{r}
fig <- ggplot(data, aes(x = log(AggClaim))) +
  geom_density(color = "lightblue", linewidth = 1.3, adjust = 1.2, fill = "lightblue") +
  geom_histogram(aes(y = ..density..), 
                 fill = "#0073C2FF", color = "white", bins = 50, alpha = 0.6) +
  labs(
    x = "Monto del reclamo (escala log)",
    y = "Densidad"
  ) +
  theme_minimal()
ggsave("res/densidad.pdf", fig, width = 8, height = 4)
```

```{r, message=FALSE}
fig <- data %>%
  mutate(month = floor_date(AccDate, "month")) %>%
  group_by(month) %>%
  summarise(Reclamos = n()) %>%
  ggplot(aes(x = month, y = Reclamos)) +
  geom_line(color = "#E69F00", linewidth = 1) +
  geom_point(color = "#F17F00", size = 1.5) +
  geom_smooth(method = "loess", se = FALSE, color = "#0072B2") +  
  labs(
    x = "Fecha del accidente (mes)",
    y = "Número de reclamos"
  ) +
  theme_minimal()
ggsave("res/evol.pdf", fig, width = 8, height = 4)
```

```{r}
fig <- ggplot(data, aes(x = log(AggClaim), y = OpTime)) +
  geom_density_2d_filled(contour_var = "density", alpha = 0.85) +
  scale_fill_manual(
    values = colorRampPalette(c("#02102a", "#3182bd", "#fef0d9", "gray")[4:1])(13)
  ) +
  labs(
    x = "Monto agregado del reclamo (escala log)",
    y = "Tiempo operativo (OpTime)",
    fill = "Densidad"
  ) +
  theme_minimal()
ggsave("res/calor.pdf", fig, width = 8, height = 4)
```

# Chain Ladder
```{r}
datos_sli <- data %>%
  mutate(
    ocurrencia = year(AccDate),
    reporte = year(ReportDate),
    k  = pmax(0, reporte - ocurrencia)
  ) %>%
  group_by(ocurrencia, k) %>%
  summarise(inc = sum(AggClaim, na.rm = TRUE), .groups = "drop")

  triangulo <- pivot_wider(datos_sli, names_from = k, values_from = inc, values_fill = 0) %>%
    arrange(ocurrencia)
  triangulo <- data.frame(triangulo)
  rownames(triangulo) <- triangulo[, 1]  
  triangulo <- triangulo[, -1]           
  colnames(triangulo) <- 0:max(datos_sli$k, na.rm = TRUE)
```

```{r}
cumtria <- function(triangulo) {
  n <- nrow(triangulo)
  mask <- upper.tri(matrix(1, n, n), diag = T)[, n:1]
  acum <- t(apply(triangulo, 1, cumsum)) * mask
  acum[!mask] <- 0
  acum <- data.frame(acum)
  colnames(acum) <- 0:(n - 1)
  return(acum)
}
```

```{r}
tria <- cumtria(triangulo)
n <- nrow(tria)
mask <- upper.tri(matrix(TRUE, n, n), diag = TRUE)[, n:1]  
tria[!mask] <- NA 
tria <- as.triangle(as.matrix(tria))
CL <- MackChainLadder(tria)
```

```{r}
(tria <- CL$FullTriangle)
```

```{r}
CL$f
```


```{r}
# Reserva
sum(tria[,6]-diag(tria))
```

# Estimación por cópulas
## Intento 3

```{r}
empirical_quantile_fun <- function(x) {
  x <- sort(x)
  n <- length(x)
  p <- ((1:n) - 0.5) / n           # probs for sample quantiles
  # return a function q(u) for u in (0,1)
  function(u) {
    if (any(u <= 0) || any(u >= 1)) {
      # clamp slightly
      u <- pmin(pmax(u, 1e-10), 1 - 1e-10)
    }
    approx(p, x, xout = u, rule = 2)$y
  }
}

# ---------- 1) Prepare data (AY_cont, DY_cont, counts by origin) ----------
prepare_ay_dy <- function(data) {
  if (!inherits(data$AccDate, "Date")) data$AccDate <- as.Date(data$AccDate)
  if (!inherits(data$ReportDate, "Date")) data$ReportDate <- as.Date(data$ReportDate)
  stopifnot(all(!is.na(data$AccDate)))
  stopifnot(all(!is.na(data$ReportDate)))
  # continuous accident year: e.g., 2014.5 if mid-year (use day-of-year / 365)
  doy_acc <- as.integer(format(data$AccDate, "%j"))
  AY_cont <- as.numeric(format(data$AccDate, "%Y")) + (doy_acc - 1)/365
  # continuous development in years (ReportDate - AccDate) in days / 365
  DY_cont <- as.numeric(difftime(data$ReportDate, data$AccDate, units = "days")) / 365
  if (any(DY_cont < 0)) stop("Hay registros con ReportDate < AccDate")
  data2 <- data
  data2$AY_cont <- AY_cont
  data2$DY_cont <- DY_cont
  data2$AccYear <- as.integer(format(data2$AccDate, "%Y"))
  return(data2)
}

# ---------- 2) Fit copula on pseudo-observations (choice of family) ----------
fit_copula_pobs <- function(AY_cont, DY_cont, family = c("frank","clayton","gumbel")) {
  family <- match.arg(family)
  n <- length(AY_cont)
  # pseudo-observations: ranks/(n+1)
  U <- rank(AY_cont, ties.method = "average") / (n + 1)
  V <- rank(DY_cont, ties.method = "average") / (n + 1)
  uv <- cbind(U, V)
  if (family == "frank") {
    cop <- frankCopula(dim = 2)
  } else if (family == "clayton") {
    cop <- claytonCopula(dim = 2)
  } else if (family == "gumbel") {
    cop <- gumbelCopula(dim = 2)
  }
  fit <- fitCopula(cop, data = uv, method = "ml")
  return(list(fit = fit, U = U, V = V))
}

# ---------- 3) Estimate conditional probs via simulation ----------
estimate_conditional_probs <- function(data_prepped,
                                       cop_fit,                      # output of fit_copula_pobs
                                       simulate_n = 200000,
                                       years = sort(unique(data_prepped$AccYear)),
                                       max_lag = 6,
                                       seed = 12345) {
  set.seed(seed)
  n <- nrow(data_prepped)
  # marginals empirical quantile functions
  q_AY <- empirical_quantile_fun(data_prepped$AY_cont)
  q_DY <- empirical_quantile_fun(data_prepped$DY_cont)
  # Sample from fitted copula
  fitted_copula <- cop_fit$fit@copula
  # NOTE: fitCopula returns an object with param set in @copula after fit
  # simulate
  uv_sim <- rCopula(simulate_n, fitted_copula)  # matrix (simulate_n x 2)
  Usim <- uv_sim[,1]; Vsim <- uv_sim[,2]
  # map to marginal scales
  AY_sim <- q_AY(Usim)      # continuous AY
  DY_sim <- q_DY(Vsim)      # continuous DY in years
  # compute occ years and integer lags
  occ_year_sim <- floor(AY_sim + 1e-9)  # year of occurrence
  lag_sim <- floor(DY_sim + 1e-9)       # development lag in integer years
  # restrict to years of interest
  years_vec <- years
  n_years <- length(years_vec)
  probs_matrix <- matrix(0, nrow = n_years, ncol = max_lag + 1)
  rownames(probs_matrix) <- as.character(years_vec)
  colnames(probs_matrix) <- paste0("lag_", 0:max_lag)
  for (i in seq_len(n_years)) {
    a <- years_vec[i]
    sel <- which(occ_year_sim == a)
    if (length(sel) == 0) {
      probs_matrix[i, ] <- 0
    } else {
      counts <- tabulate(pmin(lag_sim[sel], max_lag) + 1, nbins = max_lag + 1)
      probs_matrix[i, ] <- counts / length(sel)
    }
  }
  return(probs_matrix)
}

# ---------- 4) Build expected triangle (counts) ----------
build_triangle_from_probs <- function(data_prepped, probs_matrix, years = sort(unique(data_prepped$AccYear)), max_lag = 6) {
  n_years <- length(years)
  triangle <- matrix(0, nrow = n_years, ncol = max_lag + 1)
  rownames(triangle) <- as.character(years)
  colnames(triangle) <- paste0("dev_", 0:max_lag)
  # counts per origin year
  counts <- as.integer(table(factor(data_prepped$AccYear, levels = years)))
  for (i in seq_len(n_years)) {
    triangle[i, ] <- counts[i] * probs_matrix[i, ]
  }
  return(list(triangle = triangle, counts = counts))
}

build_triangle_from_probs_amount <- function(data_prepped,
                                             probs_matrix,
                                             years = sort(unique(data_prepped$AccYear)),
                                             max_lag = 6,
                                             amount_col = "AggClaim") {
  
  n_years <- length(years)
  triangle <- matrix(0, nrow = n_years, ncol = max_lag + 1)
  rownames(triangle) <- as.character(years)
  colnames(triangle) <- paste0("dev_", 0:max_lag)
  
  # sum of amounts per origin year
  # e.g. total incurred or agg claim in the origin year
  sums <- tapply(data_prepped[[amount_col]],
                 factor(data_prepped$AccYear, levels = years),
                 sum)
  
  # fill the triangle
  for (i in seq_len(n_years)) {
    triangle[i, ] <- sums[i] * probs_matrix[i, ]
  }
  
  return(list(triangle_amount = triangle, origin_amount = sums))
}

# ---------- 5) High-level wrapper ----------
estimate_copula_runoff <- function(data,
                                   family = c("frank","clayton","gumbel"),
                                   simulate_n = 200000,
                                   max_lag = 6,
                                   seed = 12345) {
  family <- match.arg(family)
  data_p <- prepare_ay_dy(data)
  years <- sort(unique(data_p$AccYear))
  # fit copula
  fit_obj <- fit_copula_pobs(data_p$AY_cont, data_p$DY_cont, family = family)
  # estimate probs via simulation
  probs <- estimate_conditional_probs(data_p, fit_obj, simulate_n = simulate_n, years = years, max_lag = max_lag, seed = seed)
  tri_out <- build_triangle_from_probs(data_p, probs, years = years, max_lag = max_lag)
  tri_amt_out <- build_triangle_from_probs_amount(data_p, probs,
                                                years = years,
                                                max_lag = max_lag,
                                                amount_col = "AggClaim")
  out <- list(
    params = fit_obj$fit,
    family = family,
    probs = probs,
    triangle_expected_counts = tri_out$triangle,
    triangle_expected_amounts = tri_amt_out$triangle_amount,
    origin_counts = tri_out$counts,
    origin_amounts = tri_amt_out$origin_amount,
    data_prepped = data_p
  )
  return(out)
}
```

```{r}
out <- estimate_copula_runoff(data, family = "frank", simulate_n = 200000, max_lag = 5)
out$probs                
out$triangle_expected_counts
```

```{r}
out$triangle_expected_amounts
```

```{r}
(final <- t(apply(out$triangle_expected_amounts, 1, cumsum)))
```

```{r}
sum(final[,6]-diag(final))
```
































